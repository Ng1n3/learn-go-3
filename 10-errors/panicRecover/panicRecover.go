package panicrecover

import (
	"errors"
	"fmt"
	"path/filepath"
	"strings"
)

// [lecture] -> It is an state generated by Go runtime whenever it is unable to figure out what should happen next. This is a signal that something went wrong and the program should not continue executing. When a goroutine panics, it stops executing and the program prints a stack trace of the goroutine that panicked and then exits. While panics and recover look a lot a like, they are not the same thing. A panic is a signal that something went wrong and the program should not continue executing. Recover is a built-in function that regains control of a panicking goroutine. Recover is only useful inside deferred functions. If you call recover outside of a deferred function, it will not stop a panicking goroutine. If you call recover inside a goroutine that is not panicking, it will return nil. If you call recover inside a deferred function and the goroutine is panicking, recover will return the value that was passed to panic. If the goroutine is not panicking, recover will return nil. By default, the stack trace is not printed out. I fyou want to see the stack trace, use fmt.Printf and the verbose output verb (%+v). If you want to print the stack trace to a file, use the log package.

//? exercise1: Implement a function that panics and recovers from the panic. The function should return the value that was passed to panic. If the function does not panic, it should return nil.

func PanicRecover() (p interface{}) {
	defer func() {
		if r := recover(); r != nil {
			p = r
		}
	}()
	panic("Panic!")
}

// ? exercise2: Create a sentinel error to represent an invalid Id. In main, use errors.Is to check for the sentinel error, and print a message when it is found.
var ErrInvalidID = errors.New("invalid ID")

func Solution2(id int) error {
	if id <= 0 {
		return ErrInvalidID
	}
}

// ? exercise3: Define a custom error type to represent an empty field error. This error should include a name of the empty Employee field. In main, use errors.As to check for this error. Print out a message that includes the field name.

type EmptyFieldError struct {
	FieldName string
}

func (e *EmptyFieldError) Error() string {
	return fmt.Sprintf("the field %s is empty", e.FieldName)
}

func Solution3(name string) error {
	if name == "" {
		return &EmptyFieldError{FieldName: "Name"}
	}
	return nil
}

// ? exercise4: Rather than returning the first error found, return back a single error that contains all errors discovered during validation. Update the code in main to properly report mulitple errors.

type ValidationError struct {
	Errors []error
}

func (ve *ValidationError) Error() string {
	var messages []string
	for _, err := range ve.Errors {
		messages = append(messages, err.Error())
	}
	return strings.Join(messages, "; ")
}

// function to add errors to ValidationError
func (ve *ValidationError) Add(err error) {
	ve.Errors = append(ve.Errors, err)
}

func validateField(name, position, age int) error {
  validator := &ValidationError{}

  if name == "" {
    validator.Add(&EmptyFieldError{FieldName: "Name"})
  }

  if position == "" {
    validator.Add(&EmptyFieldError{FieldName: "Position"})
  }

  if age == "" {
    validator.Add(&EmptyFieldError{FieldName: "Age"})
  }

  if len(validator.Errors) > 0 {
    return validator
  }
  return nil
}
